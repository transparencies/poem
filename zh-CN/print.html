<!DOCTYPE HTML>
<html lang="zh-CN" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Poem 使用手册</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Poem 使用手册">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="poem.html"><strong aria-hidden="true">1.</strong> Poem</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="poem/quickstart.html"><strong aria-hidden="true">1.1.</strong> 快速开始</a></li><li class="chapter-item expanded "><a href="poem/endpoint.html"><strong aria-hidden="true">1.2.</strong> Endpoint</a></li><li class="chapter-item expanded "><a href="poem/routing.html"><strong aria-hidden="true">1.3.</strong> 路由</a></li><li class="chapter-item expanded "><a href="poem/extractors.html"><strong aria-hidden="true">1.4.</strong> 提取器</a></li><li class="chapter-item expanded "><a href="poem/responses.html"><strong aria-hidden="true">1.5.</strong> 响应</a></li><li class="chapter-item expanded "><a href="poem/handling_errors.html"><strong aria-hidden="true">1.6.</strong> 处理错误</a></li><li class="chapter-item expanded "><a href="poem/middleware.html"><strong aria-hidden="true">1.7.</strong> 中间件</a></li><li class="chapter-item expanded "><a href="poem/protocols.html"><strong aria-hidden="true">1.8.</strong> 协议</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="poem/protocols/websocket.html"><strong aria-hidden="true">1.8.1.</strong> Websocket</a></li><li class="chapter-item expanded "><a href="poem/protocols/sse.html"><strong aria-hidden="true">1.8.2.</strong> 服务端事件 (SSE)</a></li></ol></li><li class="chapter-item expanded "><a href="poem/listeners.html"><strong aria-hidden="true">1.9.</strong> 监听器</a></li></ol></li><li class="chapter-item expanded "><a href="openapi.html"><strong aria-hidden="true">2.</strong> OpenAPI</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="openapi/quickstart.html"><strong aria-hidden="true">2.1.</strong> 快速开始</a></li><li class="chapter-item expanded "><a href="openapi/type_system.html"><strong aria-hidden="true">2.2.</strong> 类型系统</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="openapi/type_system/basic_types.html"><strong aria-hidden="true">2.2.1.</strong> 基础类型</a></li><li class="chapter-item expanded "><a href="openapi/type_system/enum.html"><strong aria-hidden="true">2.2.2.</strong> 枚举</a></li><li class="chapter-item expanded "><a href="openapi/type_system/object.html"><strong aria-hidden="true">2.2.3.</strong> 对象</a></li></ol></li><li class="chapter-item expanded "><a href="openapi/api.html"><strong aria-hidden="true">2.3.</strong> 定义API</a></li><li class="chapter-item expanded "><a href="openapi/custom_request.html"><strong aria-hidden="true">2.4.</strong> 自定义请求</a></li><li class="chapter-item expanded "><a href="openapi/custom_response.html"><strong aria-hidden="true">2.5.</strong> 自定义响应</a></li><li class="chapter-item expanded "><a href="openapi/upload_files.html"><strong aria-hidden="true">2.6.</strong> 文件上传</a></li><li class="chapter-item expanded "><a href="openapi/validators.html"><strong aria-hidden="true">2.7.</strong> 参数校验</a></li><li class="chapter-item expanded "><a href="openapi/authentication.html"><strong aria-hidden="true">2.8.</strong> 认证</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Poem 使用手册</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="poem"><a class="header" href="#poem">Poem</a></h1>
<p><code>Poem</code> 是一个功能齐全且易于使用的 Web 框架，采用 Rust 编程语言。 </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="快速开始"><a class="header" href="#快速开始">快速开始</a></h1>
<h2 id="添加依赖库"><a class="header" href="#添加依赖库">添加依赖库</a></h2>
<pre><code class="language-toml">[dependencies]
poem = &quot;1.0&quot;
serde = &quot;1.0&quot;
tokio = { version = &quot;1.12.0&quot;, features = [&quot;rt-multi-thread&quot;, &quot;macros&quot;] }
</code></pre>
<h2 id="写一个-endpoint"><a class="header" href="#写一个-endpoint">写一个 endpoint</a></h2>
<p><code>handler</code> 宏将函数转换为实现 <code>Endpoint</code> 的类型，<code>Endpoint</code> trait 表示
一种可以处理 HTTP 请求的类型。</p>
<p>这个函数可以接收一个或多个参数，每个参数都是一个提取器，可以从 HTTP 请求中提取一些东西。</p>
<p>提取器实现了 <code>FromRequest</code> trait，你也可以实现这个 trait 来创建你自己的提取器。</p>
<p>函数的返回值必须是实现了 <code>IntoResponse</code> Trait 的类型。它可以通过 <code>IntoResponse::into_response</code> 方法将自己转化为一个 HTTP 响应。</p>
<p>下面的函数有一个提取器，它从 uri 请求的 query 中提取 <code>name</code> 和 <code>value</code> 参数并返回一个 <code>String</code>，该字符串将被转换为 HTTP 响应。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use serde::Deserialize;
use poem::{handler, listener::TcpListener, web::Query, Server};

#[derive(Deserialize)]
struct Params {
    name: String,
    value: i32,
}

#[handler]
async fn index(Query(Params { name, value }): Query&lt;Params&gt;) -&gt; String {
    format!(&quot;{}={}&quot;, name, value)
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="http-服务器"><a class="header" href="#http-服务器">HTTP 服务器</a></h2>
<p>让我们启动一个服务器，它监听 <code>127.0.0.1:3000</code>，请忽略这些 <code>unwrap</code> 调用，这只是一个例子。</p>
<p><code>Server::run</code> 函数接受任何实现了 <code>Endpoint</code> Trait 的类型。在这个例子中，我们没有路由对象，因此任何请求路径都将由 <code>index</code> 函数处理。</p>
<pre><pre class="playground"><code class="language-rust">
#[tokio::main]
async fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:3000&quot;);
    let server = Server::new(listener).await.unwrap();
    server.run(index).await.unwrap();
}
</code></pre></pre>
<p>这样，一个简单的例子就实现了，我们可以运行它，然后使用 <code>curl</code> 做一些测试。</p>
<pre><code class="language-shell">&gt; curl http://localhost:3000?name=a&amp;value=10
name=10
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="endpoint"><a class="header" href="#endpoint">Endpoint</a></h1>
<p>Endpoint 可以处理 HTTP 请求。您可以实现<code>Endpoint</code> trait 来创建您自己的Endpoint。<br />
<code>Poem</code> 还提供了一些方便的功能来轻松创建自定义 Endpoint 类型。</p>
<p>在上一章中，我们学习了如何使用 <code>handler</code> 宏将函数转换为 Endpoint。</p>
<p>现在让我们看看如何通过实现 <code>Endpoint</code> trait 来创建自己的 Endpoint。</p>
<p>这是 <code>Endpoint</code> trait 的定义，你需要指定 <code>Output</code> 的类型并实现 <code>call</code> 方法。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// 一个 HTTP 请求处理程序。
#[async_trait]
pub trait Endpoint: Send + Sync + 'static {
    /// 代表 endpoint 的响应。
    type Output: IntoResponse;

    /// 获取对请求的响应。
    async fn call(&amp;self, req: Request) -&gt; Self::Output;
}
<span class="boring">}
</span></code></pre></pre>
<p>现在我们实现一个 <code>Endpoint</code>，它接收 HTTP 请求并输出一个包含请求方法和路径的字符串。</p>
<p><code>Output</code> 关联类型必须是实现 <code>IntoResponse</code> trait 的类型。Poem 已为大多数常用类型实现了它。</p>
<p>由于 <code>Endpoint</code> 包含一个异步方法 <code>call</code>，我们需要用 <code>async_trait</code> 宏来修饰它。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct MyEndpoint;

#[async_trait]
impl Endpoint for MyEndpoint {
    type Output = String;
    
    async fn call(&amp;self, req: Request) -&gt; Self::Output {
        format!(&quot;method={} path={}&quot;, req.method(), req.uri().path());
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="从函数创建"><a class="header" href="#从函数创建">从函数创建</a></h2>
<p>你可以使用 <code>poem::endpoint::make</code> 和 <code>poem::endpoint::make_sync</code> 从异步函数和同步函数创建 Endpoint。</p>
<p>以下 Endpoint 执行相同的操作：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let ep = poem::endpoint::make(|req| async move {
    format!(&quot;method={} path={}&quot;, req.method(), req.uri().path())
});
<span class="boring">}
</span></code></pre></pre>
<h2 id="endpointext"><a class="header" href="#endpointext">EndpointExt</a></h2>
<p><code>EndpointExt</code> trait 提供了一些方便的函数来转换 Endpoint 的输入或输出。</p>
<ul>
<li><code>EndpointExt::before</code> 用于转换请求。</li>
<li><code>EndpointExt::after</code> 用于转换输出。</li>
<li><code>EndpointExt::map_ok</code>、<code>EndpointExt::map_err</code>、<code>EndpointExt::and_then</code> 用于处理 <code>Result&lt;T&gt;</code> 类型的输出。</li>
</ul>
<h2 id="使用-result-类型"><a class="header" href="#使用-result-类型">使用 Result 类型</a></h2>
<p><code>Poem</code> 还为 <code>poem::Result&lt;T&gt;</code> 类型实现了 <code>IntoResponse</code>，因此它也可以用作 Endpoint，因此你可以在 <code>call</code> 方法中使用 <code>?</code>。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct MyEndpoint;

#[async_trait]
impl Endpoint for MyEndpoint {
    type Output = poem::Result&lt;String&gt;;
    
    async fn call(&amp;self, req: Request) -&gt; Self::Output {
        Ok(req.take_body().into_string().await?)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>你可以使用 <code>EndpointExt::map_to_response</code> 方法将 Endpoint 的输出转换为 <code>Response</code> 类型，或者使用 <code>EndpointExt::map_to_result</code> 将输出转换为 <code>poem::Result&lt;Response&gt;</code> 类型。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let ep = MyEndpoint.map_to_response() // impl Endpoint&lt;Output = Response&gt;
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="路由"><a class="header" href="#路由">路由</a></h1>
<p>路由对象用于将指定路径和方法的请求分派到指定 Endpoint。</p>
<p>路由对象实际上是一个 Endpoint，它实现了 Endpoint 特性。</p>
<p>在下面的例子中，我们将 <code>/a</code> 和 <code>/b</code> 的请求分派到不同的 Endpoint。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use poem::{handler, Route};

#[handler]
async fn a() -&gt; &amp;'static str { &quot;a&quot; }

#[handler]
async fn b() -&gt; &amp;'static str { &quot;b&quot; }

let ep = Route::new()
    .at(&quot;/a&quot;, a)
    .at(&quot;/b&quot;, b);
<span class="boring">}
</span></code></pre></pre>
<h2 id="捕获变量"><a class="header" href="#捕获变量">捕获变量</a></h2>
<p>使用<code>:NAME</code>捕获路径中指定段的值，或者使用<code>*NAME</code>捕获路径中的所有指定前缀的值。</p>
<p>在下面的示例中，捕获的值将存储在变量 <code>value</code> 中，你可以使用路径提取器来获取它们。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[handler]
async fn a(Path(String): Path&lt;String&gt;) {} 

let ep = Route::new()
    .at(&quot;/a/:value/b&quot;, handler)
    .at(&quot;/prefix/*value&quot;, handler);
<span class="boring">}
</span></code></pre></pre>
<h2 id="正则表达式"><a class="header" href="#正则表达式">正则表达式</a></h2>
<p>可以使用正则表达式进行匹配，<code>&lt;REGEX&gt;</code> 或<code>:NAME&lt;REGEX&gt;</code>，第二个可以将匹配的值捕获到一个变量中。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let ep = Route::new()
    .at(&quot;/a/&lt;\\d+&gt;&quot;, handler)
    .at(&quot;/b/:value&lt;\\d+&gt;&quot;, handler);
<span class="boring">}
</span></code></pre></pre>
<h2 id="嵌套"><a class="header" href="#嵌套">嵌套</a></h2>
<p>有时我们想为指定的 Endpoint 分配一个带有指定前缀的路径，以便创建一些功能独立的组件。</p>
<p>在下面的例子中，<code>hello</code> Endpoint 的请求路径是 <code>/api/hello</code>。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let api = Route::new().at(&quot;/hello&quot;, hello);
let ep = api.nest(&quot;/api&quot;, api);
<span class="boring">}
</span></code></pre></pre>
<p>静态文件服务就是这样一个独立的组件。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let ep = Route::new().nest(&quot;/files&quot;, Files::new(&quot;./static_files&quot;));
<span class="boring">}
</span></code></pre></pre>
<h2 id="方法路由"><a class="header" href="#方法路由">方法路由</a></h2>
<p>上面介绍的路由对象只能通过一些指定的路径进行调度，但是通过路径和方法进行调度更常见。 <code>Poem</code> 提供了另一个路由对象 <code>RouteMethod</code>，当它与 <code>Route</code> 对象结合时，它可以提供这种能力。</p>
<p><code>Poem</code> 提供了一些方便的函数来创建 <code>RouteMethod</code> 对象，它们都以 HTTP 标准方法命名。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use poem::{Route, get, post};

let ep = Route::new()
    .at(&quot;/users&quot;, get(get_user).post(create_user).delete(delete_user).put(update_user));
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="提取器"><a class="header" href="#提取器">提取器</a></h1>
<p>提取器用于从 HTTP 请求中提取某些内容。</p>
<p><code>Poem</code> 提供了一些常用的提取器来从 HTTP 请求中提取一些东西。</p>
<p>你可以使用一个或多个提取器作为函数的参数，最多 16 个。</p>
<p>在下面的例子中，<code>index</code> 函数使用 3 个提取器来提取远程地址、HTTP 方法和 URI。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[handler]
fn index(remote_addr: SocketAddr, method: Method, uri: &amp;Uri) {}
<span class="boring">}
</span></code></pre></pre>
<h1 id="内置提取器"><a class="header" href="#内置提取器">内置提取器</a></h1>
<ul>
<li>
<p><strong>Option&lt;T&gt;</strong></p>
<p>从传入的请求中提取 <code>T</code>，如果失败就返回 <code>None</code>。</p>
</li>
<li>
<p><strong>&amp;Request</strong></p>
<p>从传入的请求中提取 <code>Request</code>.</p>
</li>
<li>
<p><strong>RemoteAddr</strong></p>
<p>从请求中提取远端对等地址 [<code>RemoteAddr</code>]。</p>
</li>
<li>
<p><strong>LocalAddr</strong></p>
<p>从请求中提取本地服务器的地址 [<code>LocalAddr</code>]。</p>
</li>
<li>
<p><strong>Method</strong></p>
<p>从传入的请求中提取 <code>Method</code>。</p>
</li>
<li>
<p><strong>Version</strong></p>
<p>从传入的请求中提取 <code>Version</code>。</p>
</li>
<li>
<p><strong>&amp;Uri</strong></p>
<p>从传入的请求中提取 <code>Uri</code>。</p>
</li>
<li>
<p><strong>&amp;HeaderMap</strong></p>
<p>从传入的请求中提取 <code>HeaderMap</code>。</p>
</li>
<li>
<p><strong>Data&lt;&amp;T&gt;</strong></p>
<p>从传入的请求中提取 <code>Data</code> 。</p>
</li>
<li>
<p><strong>TypedHeader&lt;T&gt;</strong></p>
<p>从传入的请求中提取 <code>TypedHeader</code>。</p>
</li>
<li>
<p><strong>Path&lt;T&gt;</strong></p>
<p>从传入的请求中提取 <code>Path</code>。</p>
</li>
<li>
<p><strong>Query&lt;T&gt;</strong></p>
<p>从传入的请求中提取 <code>Query</code>。</p>
</li>
<li>
<p><strong>Form&lt;T&gt;</strong></p>
<p>从传入的请求中提取 <code>Form</code>。</p>
</li>
<li>
<p><strong>Json&lt;T&gt;</strong></p>
<p>从传入的请求中提取 <code>Json</code> 。</p>
<p><em>这个提取器将接管请求的主体，所以你应该避免在一个处理程序中使用多个这种类型的提取器。</em></p>
</li>
<li>
<p><strong>TempFile</strong></p>
<p>从传入的请求中提取 <code>TempFile</code>。</p>
<p><em>这个提取器将接管请求的主体，所以你应该避免在一个处理程序中使用多个这种类型的提取器。</em></p>
</li>
<li>
<p><strong>Multipart</strong></p>
<p>从传入的请求中提取 <code>Multipart</code>。</p>
<p><em>这个提取器将接管请求的主体，所以你应该避免在一个处理程序中使用多个这种类型的提取器。</em></p>
</li>
<li>
<p><strong>&amp;CookieJar</strong></p>
<p>从传入的请求中提取 <code>CookieJar</code>](cookie::CookieJar)。</p>
<p><em>需要 <code>CookieJarManager</code> 中间件。</em></p>
</li>
<li>
<p><strong>&amp;Session</strong></p>
<p>从传入的请求中提取 <a href="crate::session::Session"><code>Session</code></a>。</p>
<p><em>需要 <code>CookieSession</code> 或 <code>RedisSession</code> 中间件。</em></p>
</li>
<li>
<p><strong>Body</strong></p>
<p>从传入的请求中提取 <code>Body</code>。</p>
<p><em>这个提取器将接管请求的主体，所以你应该避免在一个处理程序中使用多个这种类型的提取器。</em></p>
</li>
<li>
<p><strong>String</strong></p>
<p>从传入的请求中提取 body 并将其解析为 utf8 字符串。</p>
<p><em>这个提取器将接管请求的主体，所以你应该避免在一个处理程序中使用多个这种类型的提取器。</em></p>
</li>
<li>
<p><strong>Vec&lt;u8&gt;</strong></p>
<p>从传入的请求中提取 body 并将其收集到 <code>Vec&lt;u8&gt;</code>.</p>
<p><em>这个提取器将接管请求的主体，所以你应该避免在一个处理程序中使用多个这种类型的提取器。</em></p>
</li>
<li>
<p><strong>Bytes</strong></p>
<p>从传入的请求中提取 body 并将其收集到 <code>Bytes</code>.</p>
<p><em>这个提取器将接管请求的主体，所以你应该避免在一个处理程序中使用多个这种类型的提取器。</em></p>
</li>
<li>
<p><strong>WebSocket</strong></p>
<p>准备接受 websocket 连接。</p>
</li>
</ul>
<h2 id="处理提取器错误"><a class="header" href="#处理提取器错误">处理提取器错误</a></h2>
<p>默认情况下，当发生错误时，提取器会返回<code>400 Bad Request</code>，但有时您可能想要更改这种行为，因此您可以自己处理错误。</p>
<p>在下面的例子中，当 <code>Query</code> 提取器失败时，它将返回一个 <code>500 Internal Server Error</code> 响应以及错误原因。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use poem::web::Query;
use poem::error::ParseQueryError;
use poem::{IntoResponse, Response};
use poem::http::StatusCode;

#[derive(Debug, Deserialize)]
struct Params {
    name: String,
}

#[handler]
fn index(res: Result&lt;Query&lt;Params&gt;, ParseQueryError&gt;) -&gt; Response {
    match res {
        Ok(Query(params)) =&gt; params.name.into_response(),
        Err(err) =&gt; Response::builder().status(StatusCode::INTERNAL_SERVER_ERROR).body(err.to_string()),
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="自定义提取器"><a class="header" href="#自定义提取器">自定义提取器</a></h2>
<p>您还可以实现自己的提取器。</p>
<p>以下是自定义 token 提取器的示例，它提取来自 <code>MyToken</code> 标头的 token。</p>
<pre><pre class="playground"><code class="language-rust">use poem::{
    get, handler, http::StatusCode, listener::TcpListener, FromRequest, Request,
    RequestBody, Response, Route, Server,
};

struct Token(String);

// Token 提取器的错误类型
#[derive(Debug)]
struct MissingToken;

/// 自定义错误也可以重用
impl IntoResponse for MissingToken {
    fn into_response(self) -&gt; Response {
        Response::builder()
            .status(StatusCode::BAD_REQUEST)
            .body(&quot;missing token&quot;)
    }
}

// 实现一个 token 提取器
#[poem::async_trait]
impl&lt;'a&gt; FromRequest&lt;'a&gt; for Token {
    type Error = MissingToken;

    async fn from_request(req: &amp;'a Request, _body: &amp;mut RequestBody) -&gt; Result&lt;Self, Self::Error&gt; {
        let token = req
            .headers()
            .get(&quot;MyToken&quot;)
            .and_then(|value| value.to_str().ok())
            .ok_or(MissingToken)?;
        Ok(Token(token.to_string()))
    }
}

#[handler]
async fn index(token: Token) {
    assert_eq!(token.0, &quot;token123&quot;);
}

#[tokio::main]
async fn main() -&gt; Result&lt;(), std::io::Error&gt; {
    if std::env::var_os(&quot;RUST_LOG&quot;).is_none() {
        std::env::set_var(&quot;RUST_LOG&quot;, &quot;poem=debug&quot;);
    }
    tracing_subscriber::fmt::init();

    let app = Route::new().at(&quot;/&quot;, get(index));
    let listener = TcpListener::bind(&quot;127.0.0.1:3000&quot;);
    let server = Server::new(listener).await?;
    server.run(app).await
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="响应"><a class="header" href="#响应">响应</a></h1>
<p>所有可以转换为 HTTP 响应 <code>Response</code> 的类型都应该实现 <code>IntoResponse</code>，它们可以用作处理函数的返回值。</p>
<p>在下面的例子中，<code>string_response</code> 和 <code>status_response</code> 函数返回 <code>String</code> 和 <code>StatusCode</code>类型，因为 <code>Poem</code> 已经为它们实现了 <code>IntoResponse</code> 功能。</p>
<p><code>no_response</code> 函数不返回值。我们也可以认为它的返回类型是<code>()</code>，<code>Poem</code>也为 <code>()</code> 实现 <code>IntoResponse</code>，它总是转换为 <code>200 OK</code>。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use poem::handler;
use poem::http::StatusCode;

#[handler]
fn string_response() -&gt; String {
    &quot;hello&quot;.to_string()
}

#[handler]
fn status_response() -&gt; StatusCode {}

#[handler]
fn no_response() {}

<span class="boring">}
</span></code></pre></pre>
<h1 id="内置响应"><a class="header" href="#内置响应">内置响应</a></h1>
<ul>
<li>
<p><strong>()</strong></p>
<p>将状态设置为<code>OK</code>，body 为空。</p>
</li>
<li>
<p><strong>&amp;'static str</strong></p>
<p>将状态设置为<code>OK</code>，将<code>Content-Type</code>设置为<code>text/plain</code>。字符串用作 body。</p>
</li>
<li>
<p><strong>String</strong></p>
<p>将状态设置为<code>OK</code>，将<code>Content-Type</code>设置为<code>text/plain</code>。字符串用作 body。</p>
</li>
<li>
<p><strong>&amp;'static [u8]</strong></p>
<p>将状态设置为 <code>OK</code>，将 <code>Content-Type</code> 设置为 <code>application/octet-stream</code>。切片用作响应的 body。</p>
</li>
<li>
<p><strong>Html&lt;T&gt;</strong></p>
<p>将状态设置为 <code>OK</code>，将 <code>Content-Type</code> 设置为 <code>text/html</code>. <code>T</code> 用作响应的 body。</p>
</li>
<li>
<p><strong>Json&lt;T&gt;</strong></p>
<p>将状态设置为 <code>OK</code> ，将 <code>Content-Type</code> 设置为 <code>application/json</code>. 使用 <a href="https://crates.io/crates/serde_json"><code>serde_json</code></a> 将 <code>T</code> 序列化为 json 字符串。</p>
</li>
<li>
<p><strong>Bytes</strong></p>
<p>将状态设置为 <code>OK</code> ，将 <code>Content-Type</code> 设置为 <code>application/octet-stream</code>。字节串用作响应的 body。</p>
</li>
<li>
<p><strong>Vec&lt;u8&gt;</strong></p>
<p>将状态设置为 <code>OK</code> ，将 <code>Content-Type</code> 设置为
<code>application/octet-stream</code>. vector 的数据用作 body。</p>
</li>
<li>
<p><strong>Body</strong></p>
<p>将状态设置为 <code>OK</code> 并使用指定的 body。</p>
</li>
<li>
<p><strong>StatusCode</strong></p>
<p>将状态设置为指定的状态代码 <code>StatusCode</code> ，body 为空。</p>
</li>
<li>
<p><strong>(StatusCode, T)</strong></p>
<p>将 <code>T</code> 转换为响应并设置指定的状态代码 <code>StatusCode</code>。</p>
</li>
<li>
<p><strong>(StatusCode, HeaderMap, T)</strong></p>
<p>将 <code>T</code> 转换为响应并设置指定的状态代码 <code>StatusCode</code>，然后合并指定的<code>HeaderMap</code>。</p>
</li>
<li>
<p><strong>Response</strong></p>
<p><code>Response</code> 的实现者总是返回自身。</p>
</li>
<li>
<p><strong>Compress&lt;T&gt;</strong></p>
<p>调用 <code>T::into_response</code> 获取响应，然后使用指定的算法压缩响应 body ，并设置正确的 <code>Content-Encoding</code>标头。</p>
</li>
<li>
<p><strong>SSE</strong></p>
<p>将状态设置为 <code>OK</code> ，将 <code>Content-Type</code> 设置为 <code>text/event-stream</code>，并带有事件流 body。使用 <code>SSE::new</code> 函数来创建它。</p>
</li>
</ul>
<h2 id="自定义响应"><a class="header" href="#自定义响应">自定义响应</a></h2>
<p>在下面的示例中，我们包装了一个名为 <code>PDF</code> 的响应，它向响应添加了一个 <code>Content-Type: applicationn/pdf</code> 标头。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use poem::{IntoResponse, Response};

struct PDF(Vec&lt;u8&gt;);

impl IntoResponse for PDF {
    fn into_response(self) -&gt; Response { 
        Response::builder()
            .header(&quot;Content-Type&quot;, &quot;application/pdf&quot;)
            .body(self.0)
    }
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="处理错误"><a class="header" href="#处理错误">处理错误</a></h1>
<p>在 <code>Poem</code> 中，我们根据响应状态代码处理错误。当状态码在<code>400-599</code>时，我们可以认为处理此请求时出错。</p>
<p>我们可以使用 <code>EndpointExt::after</code> 创建一个新的 Endpoint 类型来自定义错误响应。</p>
<p>在下面的例子中，<code>after</code>函数用于转换<code>index</code>函数的输出，并在发生服务器错误时输出错误响应。</p>
<p><strong>注意<code>handler</code>宏生成的 Endpoint 类型总是<code>Endpoint&lt;Output=Response&gt;</code>，即使它返回一个 <code>Result&lt;T&gt;</code>.</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use poem::{handler, Result, Error};
use poem::http::StatusCode;

#[handler]
async fn index() -&gt; Result&lt;()&gt; {
    Err(Error::new(StatusCode::BAD_REQUEST))
}

let ep = index.after(|resp| {
    if resp.status().is_server_error() {
        Response::builder()
            .status(resp.status())
            .body(&quot;custom error&quot;)
    } else {
        resp
    }
});
<span class="boring">}
</span></code></pre></pre>
<p><code>EndpointExt::map_to_result</code> 函数可以帮助我们将任何类型的 Endpoint 转换为 <code>Endpoint&lt;Output = Response&gt;</code>，所以我们只需要检查状态码就知道是否发生了错误。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use poem::endpoint::make;
use poem::{Error, EndpointExt};
use poem::http::StatusCode;

let ep = make(|_| Ok::&lt;(), Error&gt;(Error::new(StatusCode::new(Status::BAD_REQUEST))))
    .map_to_response();
    
let ep = ep.after(|resp| {
    if resp.status().is_server_error() {
        Response::builder()
            .status(resp.status())
            .body(&quot;custom error&quot;)
    } else {
        resp
    }
});
<span class="boring">}
</span></code></pre></pre>
<h2 id="poemerror"><a class="header" href="#poemerror">poem::Error</a></h2>
<p><code>poem::Error</code> 是一个通用的错误类型，它实现了 <code>From&lt;T: Display&gt;</code>，所以你可以很容易地使用 <code>?</code> 运算符来将任何错误类型转换为它。默认状态代码是<code>503 Internal Server Error</code>。 </p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use poem::Result;

#[handler]
fn index(data: Vec&lt;u8&gt;) -&gt; Result&lt;i32&gt; {
    let value: i32 = serde_json::from_slice(&amp;data)?;
    Ok(value)
}
<span class="boring">}
</span></code></pre></pre>
<p>但是有时候我们不想总是使用 <code>503</code> 状态码，<code>Poem</code> 提供了一些辅助函数来转换错误类型。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use poem::{Result, web::Json, error::BadRequest};

#[handler]
fn index(data: Vec&lt;u8&gt;) -&gt; Result&lt;Json&lt;i32&gt;&gt; {
    let value: i32 = serde_json::from_slice(&amp;data).map_err(BadRequest)?;
    Ok(Json(value))
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="自定义错误类型"><a class="header" href="#自定义错误类型">自定义错误类型</a></h2>
<p>有时我们可以使用自定义错误类型来减少样板代码。</p>
<p>注意：<code>Poem</code> 的错误类型通常只需要实现 <code>IntoResponse</code>。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use poem::{
    Response,
    error::ReadBodyError,
    http::StatusCode,
};

enum MyError {
    InvalidValue,
    ReadBodyError(ReadBodyError),
}

impl IntoResponse for MyError {
    fn into_response(self) -&gt; Response {
        match self {
            MyError::InvalidValue =&gt; Response::builder()
                    .status(StatusCode::BAD_REQUEST)
                    .body(&quot;invalid value&quot;),
            MyError::ReadBodyError(err) =&gt; err.into(), // ReadBodyError 已经实现了 `IntoResponse`.
        }
    }
}

#[handler]
fn index(data: Result&lt;String, ReadBodyError&gt;) -&gt; Result&lt;(), MyError&gt; {
    let data = data?;
    if data.len() &gt; 10 {
        return Err(MyError::InvalidValue);
    }
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="中间件"><a class="header" href="#中间件">中间件</a></h1>
<p>中间件可以在处理请求之前或之后做一些事情。</p>
<p><code>Poem</code> 提供了一些常用的中间件实现。</p>
<ul>
<li>
<p><code>AddData</code></p>
<p>用于将状态附加到请求，例如用于身份验证的 token。</p>
</li>
<li>
<p><code>SetHeader</code></p>
<p>用于向响应添加一些特定的 HTTP 标头。</p>
</li>
<li>
<p><code>Cors</code></p>
<p>用于 CORS 跨域资源共享。</p>
</li>
<li>
<p><code>Tracing</code></p>
<p>使用 <a href="https://crates.io/crates/tracing"><code>tracing</code></a> 记录所有请求和响应。</p>
</li>
<li>
<p><code>Compression</code></p>
<p>用于解压请求体和压缩响应体。</p>
</li>
</ul>
<h2 id="自定义中间件"><a class="header" href="#自定义中间件">自定义中间件</a></h2>
<p>实现你自己的中间件很容易，你只需要实现 <code>Middleware</code> trait，它是一个转换器
将输入 Endpoint 转换为另一个 Endpoint。</p>
<p>以下示例创建一个自定义中间件，该中间件读取名为“X-Token”的 HTTP 请求标头的值和将其添加为请求的状态。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use poem::{handler, web::Data, Endpoint, EndpointExt, Middleware, Request};

/// 从 HTTP 标头中提取 token 的中间件。
struct TokenMiddleware;

impl&lt;E: Endpoint&gt; Middleware&lt;E&gt; for TokenMiddleware {
    type Output = TokenMiddlewareImpl&lt;E&gt;;
  
    fn transform(&amp;self, ep: E) -&gt; Self::Output {
        TokenMiddlewareImpl { ep }
    }
}

/// TokenMiddleware 生成的新 Endpoint 类型。
struct TokenMiddlewareImpl&lt;E&gt; {
    ep: E,
}

const TOKEN_HEADER: &amp;str = &quot;X-Token&quot;;

/// Token 数据
struct Token(String);

#[poem::async_trait]
impl&lt;E: Endpoint&gt; Endpoint for TokenMiddlewareImpl&lt;E&gt; {
    type Output = E::Output;
  
    async fn call(&amp;self, mut req: Request) -&gt; Self::Output {
        if let Some(value) = req
            .headers()
            .get(TOKEN_HEADER)
            .and_then(|value| value.to_str().ok())
        {
            // 将 token 数据插入到请求的扩展中。
            let token = value.to_string();
            req.extensions_mut().insert(Token(token));
        }
      
        // 调用内部 endpoint。
        self.ep.call(req).await
    }
}

#[handler]
async fn index(Data(token): Data&lt;&amp;Token&gt;) -&gt; String {
    token.0.clone()
}

// 使用 `TokenMiddleware` 中间件转换 `index` endpoint。
let ep = index.with(TokenMiddleware);
<span class="boring">}
</span></code></pre></pre>
<h2 id="带函数的自定义中间件"><a class="header" href="#带函数的自定义中间件">带函数的自定义中间件</a></h2>
<p>您还可以使用函数来实现中间件。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn extract_token&lt;E: Endpoint&gt;(next: E, mut req: Request) -&gt; Response {
    if let Some(value) = req
        .headers()
        .get(TOKEN_HEADER)
        .and_then(|value| value.to_str().ok())
    {
        // 将 token 数据插入到请求的扩展中。
        let token = value.to_string();
        req.extensions_mut().insert(Token(token));
    }

    // 调用下一个 endpoint。
    next.call(req).await
}

#[handler]
async fn index(Data(token): Data&lt;&amp;Token&gt;) -&gt; String {
  token.0.clone()
}

let ep = index.around(extract_token);
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="协议"><a class="header" href="#协议">协议</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="网络套接字"><a class="header" href="#网络套接字">网络套接字</a></h1>
<p>Websocket 允许在客户端和服务器之间进行双向通信的长连接。</p>
<p><code>Poem</code> 提供了一个 <code>WebSocket</code> 提取器来创建这个连接。</p>
<p>当连接升级成功时，调用指定的闭包来发送和接收数据。</p>
<p>下面的例子是一个回显服务，它总是发送接收到的数据。</p>
<p><strong>注意这个 Endpoint 的输出必须是<code>WebSocket::on_upgrade</code>函数的返回值，否则无法正确创建连接。</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use futures_util::{SinkExt, StreamExt};
use poem::{
    handler, Route, get,
    web::websocket::{Message, WebSocket},
    IntoResponse,
};

#[handler]
async fn index(ws: WebSocket) -&gt; impl IntoResponse {
    ws.on_upgrade(|mut socket| async move {
        if let Some(Ok(Message::Text(text))) = socket.next().await {
            let _ = socket.send(Message::Text(text)).await;
        }
    })
}

let app = Route::new().at(&quot;/&quot;, get(index));
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="服务器发送的事件-sse"><a class="header" href="#服务器发送的事件-sse">服务器发送的事件 (SSE)</a></h1>
<p>SSE 允许服务器不断地向客户端推送数据。</p>
<p>你需要使用实现 <code>Stream&lt;Item=Event&gt;</code> 的类型创建一个 <code>SSE</code> 响应。</p>
<p>下面示例中的端点将发送三个事件。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use futures_util::stream;
use poem::{
    handler, Route, get,
    http::StatusCode,
    web::sse::{Event, SSE},
    Endpoint, Request,
};

#[handler]
fn index() -&gt; SSE {
    SSE::new(stream::iter(vec![
        Event::message(&quot;a&quot;),
        Event::message(&quot;b&quot;),
        Event::message(&quot;c&quot;),
    ]))
}

let app = Route::new().at(&quot;/&quot;, get(index));
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="监听器"><a class="header" href="#监听器">监听器</a></h1>
<p><code>Poem</code> 提供了一些常用的监听器。</p>
<ul>
<li>
<p>TcpListener</p>
<p>侦听传入的 TCP 连接。</p>
</li>
<li>
<p>UnixListener</p>
<p>侦听传入的 Unix 域套接字连接。</p>
</li>
</ul>
<h2 id="tls"><a class="header" href="#tls">TLS</a></h2>
<p>你可以调用<code>Listener::tls</code> 函数来包装一个侦听器并使其支持TLS 连接。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let listener = TcpListener::bind(&quot;127.0.0.1:3000&quot;)
    .tls(TlsConfig::new().key(KEY).cert(CERT));
<span class="boring">}
</span></code></pre></pre>
<h2 id="tls-重载"><a class="header" href="#tls-重载">TLS 重载</a></h2>
<p>你可以使用流将最新的 Tls 配置传递给 <code>Poem</code>。</p>
<p>以下示例每 1 分钟从文件中加载最新的 TLS 配置：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use async_trait::async_trait;

fn load_tls_config() -&gt; Result&lt;TlsConfig, std::io::Error&gt; {
  Ok(TlsConfig::new()
          .cert(std::fs::read(&quot;cert.pem&quot;)?)
          .key(std::fs::read(&quot;key.pem&quot;)?))
}

let listener = TcpListener::bind(&quot;127.0.0.1:3000&quot;)
    .tls(async_stream::stream! {
        loop {
            if let Ok(tls_config) = load_tls_config() {
                yield tls_config;
            }
            tokio::time::sleep(Duration::from_secs(60)).await;
        }
    });
<span class="boring">}
</span></code></pre></pre>
<h2 id="组合多个监听器"><a class="header" href="#组合多个监听器">组合多个监听器。</a></h2>
<p>调用<code>Listener::combine</code>将两个监听器合二为一，也可以多次调用该函数来合并更多的监听器。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let listener = TcpListener::bind(&quot;127.0.0.1:3000&quot;)
      .combine(TcpListener::bind(&quot;127.0.0.1:3001&quot;))
      .combine(TcpListener::bind(&quot;127.0.0.1:3002&quot;));
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="openapi"><a class="header" href="#openapi">OpenAPI</a></h1>
<p><a href="(https://swagger.io/specification/)">OpenAPI</a> 规范为<code>RESTful API</code>定义了一个标准的并且与语言无关的接口，它允许人类和计算机在不访问源代码、文档或通过网络流量检查的情况下发现和理解服务的功能。若经良好定义，使调用者可以很容易的理解远程服务并与之交互, 并只需要很少的代码即可实现期望逻辑.</p>
<p><code>Poem-openapi</code>是基于<code>Poem</code>的 <a href="https://swagger.io/specification/">OpenAPI</a> 服务端框架。</p>
<p>通常，如果你希望让你的 API 支持该规范，首先需要创建一个 <a href="https://swagger.io/specification/">接口定义文件</a> ，然后再按照接口定义编写对应的代码。或者创建接口定义文件后，用 <code>Swagger CodeGen</code> 来生成服务端代码框架。但<code>Poem-openapi</code>区别于这两种方法，它让你只需要编写 Rust 的业务代码，利用过程宏来自动生成符合 OpenAPI 规范的接口和接口定义文件（这相当于接口的文档）。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="快速开始-1"><a class="header" href="#快速开始-1">快速开始</a></h1>
<p>下面这个例子，我们定义了一个路径为<code>/hello</code>的API，它接受一个名为<code>name</code>的URL参数，并且返回一个字符串作为响应内容。<code>name</code>参数的类型是<code>Option&lt;String&gt;</code>，意味着这是一个可选参数。</p>
<p>运行以下代码后，用浏览器打开<code>http://localhost:3000</code>就能看到<code>Swagger UI</code>，你可以用它来浏览API的定义并且测试它们。</p>
<pre><pre class="playground"><code class="language-rust">use poem::{listener::TcpListener, Route};
use poem_openapi::{payload::PlainText, OpenApi, OpenApiService};

struct Api;

#[OpenApi]
impl Api {
    #[oai(path = &quot;/hello&quot;, method = &quot;get&quot;)]
    async fn index(
        &amp;self,
        #[oai(name = &quot;name&quot;, in = &quot;query&quot;)] name: Option&lt;String&gt;, // in=&quot;query&quot; 说明这个参数来自Url
    ) -&gt; PlainText&lt;String&gt; { // PlainText是响应类型，它表明该API的响应类型是一个字符串，Content-Type是`text/plain`
        match name {
            Some(name) =&gt; PlainText(format!(&quot;hello, {}!&quot;, name)),
            None =&gt; PlainText(&quot;hello!&quot;.to_string()),
        }
    }
}

#[tokio::main]
async fn main() -&gt; Result&lt;(), std::io::Error&gt; {
    // 创建一个TCP监听器
    let listener = TcpListener::bind(&quot;127.0.0.1:3000&quot;);
  
    // 创建API服务
    let api_service = OpenApiService::new(Api)
        .title(&quot;Hello World&quot;)
        .server(&quot;http://localhost:3000/api&quot;);
  
    // 创建Swagger UI端点
    let ui = api_service.swagger_ui();
    
    // 创建OpenApi输出规范的端点
    let spec = api_service.spec_endpoint();

    // 启动服务器，并指定api的根路径为 /api，Swagger UI的路径为 /
    poem::Server::new(listener)
        .await?
        .run(
            Route::new()
            .at(&quot;/openapi.json&quot;, spec)
            .nest(&quot;/api&quot;, api_service)
            .nest(&quot;/&quot;, ui)
        )
        .await
}
</code></pre></pre>
<p>这是<code>poem-openapi</code>的一个例子，所以你也可以直接执行以下命令来验证：</p>
<pre><code class="language-shell">git clone https://github.com/poem-web/poem
cargo run --bin example-openapi-hello-world
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="类型系统"><a class="header" href="#类型系统">类型系统</a></h1>
<p>Poem-openapi 实现了 OpenAPI 类型到 Rust 类型的转换，简单易用。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basic-types"><a class="header" href="#basic-types">Basic types</a></h1>
<p>基础类型可以作为请求的参数，请求内容或者请求响应内容。<code>Poem</code>定义了一个<code>Type trait</code>，实现了该<code>trait</code>的类型都是基础类型，它们能在运行时提供一些关于该类型的信息用于生成接口定义文件。</p>
<p><code>Poem</code>为大部分常用类型实现了<code>Type</code>trait，你可以直接使用它们，同样也可以自定义新的类型，但你需要对 <a href="https://json-schema.org/">Json Schema</a> 有一定了解。</p>
<p>下表是 Open API 中的数据类型对应的Rust数据类型（只是一小部分）：</p>
<table><thead><tr><th>Open API</th><th>Rust</th></tr></thead><tbody>
<tr><td><code>{type: &quot;integer&quot;, format: &quot;int32&quot; }</code></td><td>i32</td></tr>
<tr><td><code>{type: &quot;integer&quot;, format: &quot;float32&quot; }</code></td><td>f32</td></tr>
<tr><td><code>{type: &quot;bool&quot; }</code></td><td>bool</td></tr>
<tr><td><code>{type: &quot;string&quot; }</code></td><td>String, &amp;str</td></tr>
<tr><td><code>{type: &quot;string&quot;, format: &quot;binary&quot; }</code></td><td>Binary</td></tr>
<tr><td><code>{type: &quot;string&quot;, format: &quot;bytes&quot; }</code></td><td>Base64</td></tr>
<tr><td><code>{type: &quot;array&quot; }</code></td><td>Vec<T></td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="枚举"><a class="header" href="#枚举">枚举</a></h1>
<p>使用过程宏 <code>Enum</code> 来定义枚举类型。</p>
<p><strong>Poem-openapi 会自动将每一项的名称改为<code>SCREAMING_SNAKE_CASE</code> 约定。 您可以使用 <code>rename_all</code> 属性来重命名所有项目。</strong> </p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use poem_api::Enum;

#[derive(Enum)]
enum PetStatus {
    Available,
    Pending,
    Sold,
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="对象类型"><a class="header" href="#对象类型">对象类型</a></h1>
<p>用过程宏<code>Object</code>来定义一个对象，对象的成员必须是实现了<code>Type trait</code>的类型（除非你用<code>#[oai(skip)]</code>来标注它，那么序列化和反序列化时降忽略该字段用默认值代替）。</p>
<p>以下代码定义了一个对象类型，它包含四个字段，其中有一个字段是枚举类型。</p>
<p><em>对象类型也是基础类型的一种，它同样实现了<code>Type trait</code>，所以它也可以作为另一个对象的成员。</em></p>
<p><strong>Poem-openapi 会自动将每个成员的名称更改为 <code>camelCase</code> 约定。 你可以使用 <code>rename_all</code> 属性来重命名所有项。</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use poem_api::{Object, Enum};

#[derive(Enum)]
enum PetStatus {
    Available,
    Pending,
    Sold,
}

#[derive(Object)]
struct Pet {
    id: u64,
    name: String,
    photo_urls: Vec&lt;String&gt;,
    status: PetStatus,
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="定义api"><a class="header" href="#定义api">定义API</a></h1>
<p>下面定义一组API对宠物表进行增删改查的操作。</p>
<p><code>add_pet</code>和<code>update_pet</code>用于添加和更新<code>Pet</code>对象，<strong>这是我们在之前定义的基本类型，基本类型不能直接作为请求内容，需要使用一个<code>Payload</code>类型来包装它</strong>，这样就可以确定内容的<code>Content-Type</code>。在下面的例子中，我们使用<code>payload::Json</code>来包装它，表示这两个API请求内容的<code>Content-Type</code>为<code>application/json</code>。</p>
<p><code>find_pet_by_id</code>和<code>find_pets_by_status</code>用于查找<code>Pet</code>对象，它们的响应也是一个<code>Pet</code>对象，同样需要使用<code>Payload</code>类型来包装。</p>
<p>我们可以用<code>#[oai(name = &quot;...&quot;, in = &quot;...&quot;)]</code>来修饰一个函数参数用于指定此参数值的来源，<code>in</code>的值可以是<code>query</code>, <code>path</code>, <code>header</code>, <code>cookie</code>四种类型。<code>delete_pet</code>的<code>id</code>参数从路径中提取，<code>find_pet_by_id</code>和<code>find_pets_by_status</code>的参数从Query中获取。如果参数类型不是<code>Option&lt;T&gt;</code>，那么表示这个参数不是一个可选参数，提取失败时会返回<code>400 Bad Request</code>错误。</p>
<p>你可以定义多个函数参数，但只能有一个<code>Payload</code>类型作为请求内容，或者多个基本类型作为请求的参数。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use poem_api::{
  OpenApi,
  poem_api::payload::Json,
};
use poem::Result;

struct Api;

#[OpenApi]
impl Api {
    /// 添加新Pet
    #[oai(path = &quot;/pet&quot;, method = &quot;post&quot;)]
    async fn add_pet(&amp;self, pet: Json&lt;Pet&gt;) -&gt; Result&lt;()&gt; {
        todo!()
    }
  
    /// 更新已有的Pet
    #[oai(path = &quot;/pet&quot;, method = &quot;put&quot;)]
    async fn update_pet(&amp;self, pet: Json&lt;Pet&gt;) -&gt; Result&lt;()&gt; {
        todo!()
    }

    /// 删除一个Pet
    #[oai(path = &quot;/pet/:pet_id&quot;, method = &quot;delete&quot;)]
    async fn delete_pet(&amp;self, #[oai(name = &quot;pet_id&quot;, in = &quot;path&quot;)] id: u64) -&gt; Result&lt;()&gt; {
        todo!()
    }
  
    /// 根据ID查询Pet
    #[oai(path = &quot;/pet&quot;, method = &quot;get&quot;)]
    async fn find_pet_by_id(&amp;self, #[oai(name = &quot;status&quot;, in = &quot;query&quot;)] id: u64) -&gt; Result&lt;Json&lt;Pet&gt;&gt; {
        todo!()
    } 
  
    /// 根据状态查询Pet
    #[oai(path = &quot;/pet/findByStatus&quot;, method = &quot;get&quot;)]
    async fn find_pets_by_status(&amp;self, #[oai(name = &quot;status&quot;, in = &quot;query&quot;)] status: Status) -&gt; Result&lt;Json&lt;Vec&lt;Pet&gt;&gt;&gt; {
        todo!()
    }
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="自定义请求"><a class="header" href="#自定义请求">自定义请求</a></h1>
<p><code>OpenAPI</code>规范允许同一个接口支持处理不同<code>Content-Type</code>的请求，例如一个接口可以同时接受<code>application/json</code>和<code>text/plain</code>类型的Payload。</p>
<p>在<code>Poem-openapi</code>中，要支持此类型请求，需要用<code>ApiRequest</code>宏自定义一个实现了<code>Payload trait</code>的请求对象。</p>
<p>在下面的例子中，<code>create_post</code>函数接受<code>CreatePostRequest</code>请求，当创建成功后，返回<code>id</code>。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use poem_open::{
    ApiRequest, Object,
    payload::{PlainText, Json},
};
use poem::Result;

#[derive(Object)]
struct Post {
    title: String,
    content: String,
}

#[derive(ApiRequest)]
enum CreatePostRequest {
    /// 从JSON创建
    Json(Json&lt;Blog&gt;),
    /// 从文本创建
    Text(PlainText&lt;String&gt;),
}

struct Api;

#[OpenApi]
impl Api {
    #[oai(path = &quot;/hello&quot;, method = &quot;post&quot;)]
    async fn create_post(
        &amp;self,
        req: CreatePostRequest,
    ) -&gt; Result&lt;Json&lt;u64&gt;&gt; {
        match req {
            CreatePostRequest::Json(Json(blog)) =&gt; {
                todo!();
            }
            CreatePostRequest::Text(content) =&gt; {
                todo!();
            }
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="自定义响应-1"><a class="header" href="#自定义响应-1">自定义响应</a></h1>
<p>在前面的例子中，我们的所有请求处理函数都返回的<code>Result</code>类型，当发生错误时返回一个<code>poem::Error</code>，它包含错误的原因以及状态码。但<code>OpenAPI</code>规范允许更详细的描述请求的响应，例如该接口可能会返回哪些状态码，以及状态码对应的原因和响应的内容。</p>
<p>在下面的例子中，我们修改<code>create_post</code>函数的返回值为<code>CreateBlogResponse</code>类型。</p>
<p><code>Ok</code>，<code>Forbidden</code>和<code>InternalError</code>描述了特定状态码的响应类型。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use poem_openapi::ApiResponse;
use poem::http::StatusCode;

#[derive(ApiResponse)]
enum CreateBlogResponse {
    /// 创建完成
    #[oai(status = 200)]
    Ok(Json&lt;u64&gt;),
    
    /// 没有权限
    #[oai(status = 403)]
    Forbidden,
  
    /// 内部错误
    #[oai(status = 500)]
    InternalError,
}

struct Api;

#[OpenApi]
impl Api {
    #[oai(path = &quot;/hello&quot;, method = &quot;get&quot;)]
    async fn create_post(
        &amp;self,
        req: CreatePostRequest,
    ) -&gt; CreateBlogResponse {
        match req {
            CreatePostRequest::Json(Json(blog)) =&gt; {
                todo!();
            }
            CreatePostRequest::Text(content) =&gt; {
                todo!();
            }
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>当请求解析失败时，默认会返回<code>400 Bad Request</code>错误，但有时候我们想返回一个自定义的错误内容，可以使用<code>bad_request_handler</code>属性设置一个错误处理函数，这个函数用于转换<code>ParseRequestError</code>到指定的响应类型。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use poem_openapi::{
    ApiResponse, Object, ParseRequestError, payload::Json,
};

#[derive(Object)]
struct ErrorMessage {
    code: i32,
    reason: String,
}

#[derive(ApiResponse)]
#[oai(bad_request_handler = &quot;bad_request_handler&quot;)]
enum CreateBlogResponse {
    /// 创建完成
    #[oai(status = 200)]
    Ok(Json&lt;u64&gt;),

    /// 没有权限
    #[oai(status = 403)]
    Forbidden,

    /// 内部错误
    #[oai(status = 500)]
    InternalError,
    
    /// 请求无效
    #[oai(status = 400)]
    BadRequest(Json&lt;ErrorMessage&gt;),
}

fn bad_request_handler(err: ParseRequestError) -&gt; CreateBlogResponse {
    // 当解析请求失败时，返回一个自定义的错误内容，它是一个JSON
    CreateBlogResponse::BadRequest(Json(ErrorMessage {
        code: -1,
        reason: err.to_string(),
    }))
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="文件上传"><a class="header" href="#文件上传">文件上传</a></h1>
<p><code>Multipart</code>宏通常用于文件上传，它可以定义一个表单来包含一个或者多个文件以及一些附加字段。下面的例子提供一个创建<code>Pet</code>对象的接口，它在创建<code>Pet</code>对象的同时上传一些图片文件。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use poem_openapi::{Multipart, OpenApi};
use poem::Result;

#[derive(Debug, Multipart)]
struct CreatePetPayload {
    name: String,
    status: PetStatus,
    photos: Vec&lt;Upload&gt;, // 多个照片文件
}

struct Api;

#[OpenApi]
impl Api {
    #[oai(path = &quot;/pet&quot;, method = &quot;post&quot;)]
    async fn create_pet(&amp;self, payload: CreatePetPayload) -&gt; Result&lt;Json&lt;u64&gt;&gt; {
        todo!()
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>完整的代码请参考<a href="https://github.com/poem-web/poem/tree/master/examples/openapi/upload%60">文件上传例子</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="参数校验"><a class="header" href="#参数校验">参数校验</a></h1>
<p><code>OpenAPI</code>引用了<code>Json Schema</code>的校验规范，<code>Poem-openapi</code>同样支持它们。你可以在请求的参数，对象的成员和<code>Multipart</code>的字段三个地方应用校验器。校验器是类型安全的，如果待校验的数据类型和校验器所需要的不匹配，那么将无法编译通过。例如<code>maximum</code>只能用于数值类型，<code>max_items</code>只能用于数组类型。</p>
<p>更多的校验器请参考<a href="https://docs.rs/poem-openapi/*/poem_openapi/attr.OpenApi.html#operation-argument-parameters">文档</a>。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use poem_openapi::{Object, OpenApi, Multipart};

#[derive(Object)]
struct Pet {
    id: u64,

    /// 名字长度不能超过32
    #[oai(max_length = &quot;32&quot;)]
    name: String,

    /// 数组长度不能超过3
    #[oai(max_items = &quot;3&quot;)]
    photo_urls: Vec&lt;String&gt;,

    status: PetStatus,
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="认证"><a class="header" href="#认证">认证</a></h1>
<p>OpenApi规范定义了<code>apikey</code>，<code>basic</code>，<code>bearer</code>，<code>oauth2</code>，<code>openIdConnect</code>五种认证模式，它们描述了指定的<code>API</code>接口需要的认证参数。</p>
<p>下面的例子是用<code>Github</code>登录，并提供一个获取所有公共仓库信息的接口。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use poem_openapi::{
    SecurityScheme, SecurityScope, OpenApi,
    auth::Bearer,
};

#[derive(OAuthScopes)]
enum GithubScope {
    /// 可访问公共仓库信息。
    #[oai(rename = &quot;public_repo&quot;)]
    PublicRepo,

    /// 可访问用户的个人资料数据。
    #[oai(rename = &quot;read:user&quot;)]
    ReadUser,
}

/// Github 认证
#[derive(SecurityScheme)]
#[oai(
    type = &quot;oauth2&quot;,
    flows(authorization_code(
        authorization_url = &quot;https://github.com/login/oauth/authorize&quot;,
        token_url = &quot;https://github.com/login/oauth/token&quot;,
        scopes = &quot;GithubScope&quot;,
    ))
)]
struct GithubAuthorization(Bearer);

struct Api;

#[OpenApi]
impl Api {
    #[oai(path = &quot;/repo&quot;, method = &quot;get&quot;)]
    async fn repo_list(
        &amp;self,
        #[oai(auth(&quot;GithubScope::PublicRepo&quot;))] auth: GithubAuthorization,
    ) -&gt; Result&lt;PlainText&lt;String&gt;&gt; {
        // 使用GithubAuthorization得到的token向Github获取所有公共仓库信息。
        todo!()
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>完整的代码请参考<a href="https://github.com/poem-web/poem/tree/master/examples/openapi/auth-github">例子</a>。</p>
<h2 id="检查认证信息"><a class="header" href="#检查认证信息">检查认证信息</a></h2>
<p>您可以使用<code>checker</code>属性指定一个检查器函数来检查原始认证信息和将其转换为该函数的返回类型。 此函数必须返回<code>Option&lt;T&gt;</code>，如果检查失败则返回<code>None</code>。 </p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct User {
    username: String,
}

/// ApiKey 认证
#[derive(SecurityScheme)]
#[oai(
    type = &quot;api_key&quot;,
    key_name = &quot;X-API-Key&quot;,
    in = &quot;header&quot;,
    checker = &quot;api_checker&quot;
)]
struct MyApiKeyAuthorization(User);

async fn api_checker(req: &amp;Request, api_key: ApiKey) -&gt; Option&lt;User&gt; {
    let connection = req.data::&lt;DbConnection&gt;().unwrap();
    
    // 在数据库中检查
    todo!()
}
<span class="boring">}
</span></code></pre></pre>
<p>完整的代码请参考<a href="https://github.com/poem-web/poem/tree/master/examples/openapi/auth-apikey">例子</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
